// Generated by CoffeeScript 1.9.0
var Account, AccountConfigError, CONSTANTS, Compiler, ImapPool, ImapReporter, Mailbox, Message, SMTPConnection, async, cozydb, log, nodemailer, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

cozydb = require('cozydb');

module.exports = Account = cozydb.getModel('Account', {
  label: String,
  name: String,
  login: String,
  password: String,
  accountType: String,
  smtpServer: String,
  smtpPort: Number,
  smtpSSL: Boolean,
  smtpTLS: Boolean,
  smtpLogin: String,
  smtpPassword: String,
  smtpMethod: String,
  imapServer: String,
  imapPort: Number,
  imapSSL: Boolean,
  imapTLS: Boolean,
  inboxMailbox: String,
  flaggedMailbox: String,
  draftMailbox: String,
  sentMailbox: String,
  trashMailbox: String,
  junkMailbox: String,
  allMailbox: String,
  favorites: [String]
});

Mailbox = require('./mailbox');

Message = require('./message');

Compiler = require('nodemailer/src/compiler');

ImapPool = require('../imap/pool');

ImapReporter = require('../imap/reporter');

AccountConfigError = require('../utils/errors').AccountConfigError;

nodemailer = require('nodemailer');

SMTPConnection = require('nodemailer/node_modules/' + 'nodemailer-smtp-transport/node_modules/smtp-connection');

log = require('../utils/logging')({
  prefix: 'models:account'
});

_ = require('lodash');

async = require('async');

CONSTANTS = require('../utils/constants');

require('../utils/socket_handler').wrapModel(Account, 'account');

Account.prototype.doASAP = function(operation, callback) {
  return ImapPool.get(this.id).doASAP(operation, callback);
};

Account.prototype.isTest = function() {
  return this.accountType === 'TEST';
};

Account.prototype.isRefreshing = function() {
  return ImapPool.get(this.id).isRefreshing;
};

Account.prototype.setRefreshing = function(value) {
  return ImapPool.get(this.id).isRefreshing = value;
};

Account.refreshAllAccounts = function(limit, onlyFavorites, callback) {
  return Account.request('all', function(err, accounts) {
    var options;
    if (err) {
      return callback(err);
    }
    options = {
      accounts: accounts,
      limitByBox: limit,
      onlyFavorites: onlyFavorites,
      firstImport: false
    };
    return Account.refreshAccounts(options, callback);
  });
};

Account.removeOrphansAndRefresh = function(limitByBox, onlyFavorites, callback) {
  return Account.request('all', function(err, accounts) {
    var existingAccountIDs;
    if (err) {
      return callback(err);
    }
    existingAccountIDs = accounts.map(function(account) {
      return account.id;
    });
    return Mailbox.removeOrphans(existingAccountIDs, function(err, existingMailboxIDs) {
      if (err) {
        return callback(err);
      }
      return Message.removeOrphans(existingMailboxIDs, function(err) {
        var options;
        if (err) {
          return callback(err);
        }
        options = {
          accounts: accounts,
          limitByBox: limitByBox,
          onlyFavorites: onlyFavorites,
          firstImport: false,
          periodic: CONSTANTS.REFRESH_INTERVAL
        };
        return Account.refreshAccounts(options, callback);
      });
    });
  });
};

Account.refreshAccounts = function(options, callback) {
  var accounts, firstImport, limitByBox, onlyFavorites, periodic;
  accounts = options.accounts, limitByBox = options.limitByBox, onlyFavorites = options.onlyFavorites, firstImport = options.firstImport, periodic = options.periodic;
  return async.eachSeries(accounts, function(account, cb) {
    log.debug("refreshing account " + account.label);
    if (account.isTest()) {
      return cb(null);
    }
    if (account.isRefreshing()) {
      return cb(null);
    }
    return account.imap_fetchMails(limitByBox, onlyFavorites, firstImport, function(err) {
      log.debug("done refreshing account " + account.label);
      if (err) {
        log.error("CANT REFRESH ACCOUNT", account.id, account.label, err);
      }
      return cb(null);
    });
  }, function(err) {
    if (periodic != null) {
      setTimeout(function() {
        log.debug("doing periodic refresh");
        options.onlyFavorites = true;
        options.limitByBox = CONSTANTS.LIMIT_BY_BOX;
        return Account.refreshAccounts(options);
      }, periodic);
    }
    if (callback != null) {
      return callback(err);
    }
  });
};

Account.createIfValid = function(data, callback) {
  var account, toFetch;
  account = new Account(data);
  toFetch = null;
  return async.series([
    function(cb) {
      log.debug("create#testConnections");
      return account.testConnections(cb);
    }, function(cb) {
      log.debug("create#cozy");
      return Account.create(account, function(err, created) {
        if (err) {
          return cb(err);
        }
        account = created;
        return cb(null);
      });
    }, function(cb) {
      log.debug("create#refreshBoxes");
      return account.imap_refreshBoxes(function(err, boxes) {
        if (err) {
          return cb(err);
        }
        toFetch = boxes;
        return cb(null);
      });
    }, function(cb) {
      log.debug("create#scan");
      return account.imap_scanBoxesForSpecialUse(toFetch, cb);
    }
  ], function(err) {
    if (err) {
      return callback(err);
    }
    return callback(null, account);
  });
};

Account.checkParams = function(data, callback) {
  var account;
  account = new Account(data);
  return account.testConnections(callback);
};

Account.prototype.testConnections = function(callback) {
  if (this.isTest()) {
    return callback(null);
  }
  return this.testSMTPConnection((function(_this) {
    return function(err) {
      if (err) {
        return callback(err);
      }
      return ImapPool.test(_this, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null);
      });
    };
  })(this));
};

Account.prototype.forgetBox = function(boxid, callback) {
  var attribute, changes, _i, _len, _ref;
  changes = {};
  _ref = Object.keys(Mailbox.RFC6154);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    attribute = _ref[_i];
    if (this[attribute] === boxid) {
      changes[attribute] = null;
    }
  }
  if (__indexOf.call(this.favorites, boxid) >= 0) {
    changes.favorites = _.without(this.favorites, boxid);
  }
  if (Object.keys(changes).length) {
    return this.updateAttributes(changes, callback);
  } else {
    return callback(null);
  }
};

Account.prototype.destroyEverything = function(callback) {
  return async.series([
    (function(_this) {
      return function(cb) {
        return _this.destroy(cb);
      };
    })(this), (function(_this) {
      return function(cb) {
        return Mailbox.destroyByAccount(_this.id, cb);
      };
    })(this), (function(_this) {
      return function(cb) {
        return Message.safeDestroyByAccountID(_this.id, cb);
      };
    })(this)
  ], callback);
};

Account.prototype.toClientObject = function(callback) {
  var rawObject;
  rawObject = this.toObject();
  if (rawObject.favorites == null) {
    rawObject.favorites = [];
  }
  return Mailbox.rawRequest('treeMap', {
    startkey: [this.id],
    endkey: [this.id, {}],
    include_docs: true
  }, function(err, rows) {
    if (err) {
      return callback(err);
    }
    rawObject.mailboxes = rows.map(function(row) {
      var _base;
      if ((_base = row.doc).id == null) {
        _base.id = row.id;
      }
      return _.pick(row.doc, 'id', 'label', 'attribs', 'tree');
    });
    return Mailbox.getCounts(null, function(err, counts) {
      var box, count, _i, _len, _ref;
      if (err) {
        return callback(err);
      }
      _ref = rawObject.mailboxes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        box = _ref[_i];
        count = counts[box.id] || {
          total: 0,
          unread: 0,
          recent: 0
        };
        box.nbTotal = count.total;
        box.nbUnread = count.unread;
        box.nbRecent = count.recent;
      }
      return callback(null, rawObject);
    });
  });
};

Account.clientList = function(callback) {
  return Account.request('all', function(err, accounts) {
    if (err) {
      return callback(err);
    }
    return async.map(accounts, function(account, cb) {
      return account.toClientObject(cb);
    }, callback);
  });
};

Account.prototype.imap_getBoxes = function(callback) {
  log.debug("getBoxes");
  return this.doASAP(function(imap, cb) {
    return imap.getBoxesArray(cb);
  }, function(err, boxes) {
    return callback(err, boxes || []);
  });
};

Account.prototype.imap_refreshBoxes = function(callback) {
  var account;
  log.debug("imap_refreshBoxes");
  account = this;
  return async.series([
    (function(_this) {
      return function(cb) {
        return Mailbox.getBoxes(_this.id, cb);
      };
    })(this), (function(_this) {
      return function(cb) {
        return _this.imap_getBoxes(cb);
      };
    })(this)
  ], function(err, results) {
    var boxToAdd, cozyBox, cozyBoxes, imapBoxes, toDestroy, toFetch, _i, _len;
    log.debug("refreshBoxes#results", results);
    if (err) {
      return callback(err);
    }
    cozyBoxes = results[0], imapBoxes = results[1];
    toFetch = [];
    toDestroy = [];
    boxToAdd = imapBoxes.filter(function(box) {
      return !_.findWhere(cozyBoxes, {
        path: box.path
      });
    });
    for (_i = 0, _len = cozyBoxes.length; _i < _len; _i++) {
      cozyBox = cozyBoxes[_i];
      if (_.findWhere(imapBoxes, {
        path: cozyBox.path
      })) {
        toFetch.push(cozyBox);
      } else {
        toDestroy.push(cozyBox);
      }
    }
    log.debug("refreshBoxes#results2");
    return async.eachSeries(boxToAdd, function(box, cb) {
      log.debug("refreshBoxes#creating", box.label);
      box.accountID = account.id;
      return Mailbox.create(box, function(err, created) {
        if (err) {
          return cb(err);
        }
        toFetch.push(created);
        return cb(null);
      });
    }, function(err) {
      if (err) {
        return callback(err);
      }
      return callback(null, toFetch, toDestroy);
    });
  });
};

Account.prototype.imap_fetchMails = function(limitByBox, onlyFavorites, firstImport, callback) {
  var account;
  log.debug("account#imap_fetchMails", limitByBox, onlyFavorites);
  account = this;
  account.setRefreshing(true);
  if (onlyFavorites == null) {
    onlyFavorites = false;
  }
  return this.imap_refreshBoxes(function(err, toFetch, toDestroy) {
    var numToFetch, reporter;
    if (err) {
      account.setRefreshing(false);
    }
    if (err) {
      return callback(err);
    }
    if (onlyFavorites) {
      toFetch = toFetch.filter(function(box) {
        var _ref;
        return _ref = box.id, __indexOf.call(account.favorites, _ref) >= 0;
      });
    }
    toFetch = toFetch.filter(function(box) {
      return box.isSelectable();
    });
    log.info("FETCHING ACCOUNT " + account.label + " : " + toFetch.length + " BOXES");
    log.info("   ", toDestroy.length, "BOXES TO DESTROY");
    numToFetch = toFetch.length + 1;
    reporter = ImapReporter.accountFetch(account, numToFetch, firstImport);
    toFetch.sort(function(a, b) {
      if (a.label === 'INBOX') {
        return -1;
      } else {
        return 1;
      }
    });
    return async.eachSeries(toFetch, function(box, cb) {
      return box.imap_fetchMails(limitByBox, firstImport, function(err) {
        var _ref;
        if (err && -1 === ((_ref = err.message) != null ? _ref.indexOf("Mailbox doesn't exist") : void 0)) {
          reporter.onError(err);
        }
        reporter.addProgress(1);
        return cb(null);
      });
    }, function(err) {
      if (err) {
        account.setRefreshing(false);
      }
      if (err) {
        return callback(err);
      }
      log.debug("account#imap_fetchMails#DONE");
      return async.eachSeries(toDestroy, function(box, cb) {
        return box.destroyAndRemoveAllMessages(cb);
      }, function(err) {
        account.setRefreshing(false);
        reporter.onDone();
        return callback(null);
      });
    });
  });
};

Account.prototype.imap_fetchMailsTwoSteps = function(callback) {
  log.debug("account#imap_fetchMails2Steps");
  return this.imap_fetchMails(100, true, true, (function(_this) {
    return function(err) {
      if (err) {
        return callback(err);
      }
      return _this.imap_fetchMails(null, false, true, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null);
      });
    };
  })(this));
};

Account.prototype.imap_createMail = function(box, message, callback) {
  var mailbuilder;
  mailbuilder = new Compiler(message).compile();
  return mailbuilder.build((function(_this) {
    return function(err, buffer) {
      if (err) {
        return callback(err);
      }
      return _this.doASAP(function(imap, cb) {
        return imap.append(buffer, {
          mailbox: box.path,
          flags: message.flags
        }, cb);
      }, function(err, uid) {
        if (err) {
          return callback(err);
        }
        return callback(null, uid);
      });
    };
  })(this));
};

Account.prototype.imap_scanBoxesForSpecialUse = function(boxes, callback) {
  var box, boxAttributes, changes, id, inboxMailbox, priorities, type, useRFC6154, _i, _j, _len, _len1, _ref;
  useRFC6154 = false;
  inboxMailbox = null;
  boxAttributes = Object.keys(Mailbox.RFC6154);
  changes = {};
  boxes.map(function(box) {
    var attribute, type, _i, _len;
    type = box.RFC6154use();
    if (box.isInbox()) {
      inboxMailbox = box.id;
    } else if (type) {
      if (!useRFC6154) {
        useRFC6154 = true;
        for (_i = 0, _len = boxAttributes.length; _i < _len; _i++) {
          attribute = boxAttributes[_i];
          changes[attribute] = null;
        }
      }
      log.debug('found', type);
      changes[type] = box.id;
    } else if (!useRFC6154 && (type = box.guessUse())) {
      log.debug('found', type, 'guess');
      changes[type] = box.id;
    }
    return box;
  });
  priorities = ['inboxMailbox', 'allMailbox', 'sentMailbox', 'draftMailbox'];
  changes.inboxMailbox = inboxMailbox;
  changes.favorites = [];
  for (_i = 0, _len = priorities.length; _i < _len; _i++) {
    type = priorities[_i];
    id = changes[type];
    if (id) {
      changes.favorites.push(id);
    }
  }
  for (_j = 0, _len1 = boxes.length; _j < _len1; _j++) {
    box = boxes[_j];
    if (changes.favorites.length < 4) {
      if ((_ref = box.id, __indexOf.call(changes.favorites, _ref) < 0) && box.isSelectable()) {
        changes.favorites.push(box.id);
      }
    }
  }
  return this.updateAttributes(changes, callback);
};

Account.prototype.sendMessage = function(message, callback) {
  var options, transport;
  if (this.isTest()) {
    return callback(null, {
      messageId: 66
    });
  }
  options = {
    port: this.smtpPort,
    host: this.smtpServer,
    secure: this.smtpSSL,
    ignoreTLS: !this.smtpTLS,
    tls: {
      rejectUnauthorized: false
    }
  };
  if ((this.smtpMethod != null) && this.smtpMethod !== 'NONE') {
    options.authMethod = this.smtpMethod;
  }
  if (this.smtpMethod !== 'NONE') {
    options.auth = {
      user: this.smtpLogin || this.login,
      pass: this.smtpPassword || this.password
    };
  }
  transport = nodemailer.createTransport(options);
  return transport.sendMail(message, callback);
};

Account.prototype.testSMTPConnection = function(callback) {
  var auth, connection, options, reject, timeout;
  if (this.isTest()) {
    return callback(null);
  }
  reject = _.once(callback);
  options = {
    port: this.smtpPort,
    host: this.smtpServer,
    secure: this.smtpSSL,
    ignoreTLS: !this.smtpTLS,
    tls: {
      rejectUnauthorized: false
    }
  };
  if ((this.smtpMethod != null) && this.smtpMethod !== 'NONE') {
    options.authMethod = this.smtpMethod;
  }
  connection = new SMTPConnection(options);
  if (this.smtpMethod !== 'NONE') {
    auth = {
      user: this.smtpLogin || this.login,
      pass: this.smtpPassword || this.password
    };
  }
  connection.once('error', function(err) {
    log.warn("SMTP CONNECTION ERROR", err);
    return reject(new AccountConfigError('smtpServer'));
  });
  timeout = setTimeout(function() {
    reject(new AccountConfigError('smtpPort'));
    return connection.close();
  }, 10000);
  return connection.connect((function(_this) {
    return function(err) {
      if (err) {
        return reject(new AccountConfigError('smtpServer'));
      }
      clearTimeout(timeout);
      if (_this.smtpMethod !== 'NONE') {
        return connection.login(auth, function(err) {
          if (err) {
            reject(new AccountConfigError('auth'));
          } else {
            callback(null);
          }
          return connection.close();
        });
      } else {
        callback(null);
        return connection.close();
      }
    };
  })(this));
};
