// Generated by CoffeeScript 1.10.0
var AccountConfigError, BadRequest, CONCURRENT_DESTROY, CONSTANTS, LIMIT_DESTROY, MSGBYPAGE, MailAdress, MailAttachment, Message, NotFound, _, async, cozydb, htmlToText, log, mailutils, ramStore, ref, uuid,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

cozydb = require('cozydb');

MailAdress = (function(superClass) {
  extend(MailAdress, superClass);

  function MailAdress() {
    return MailAdress.__super__.constructor.apply(this, arguments);
  }

  MailAdress.schema = {
    name: String,
    address: String
  };

  return MailAdress;

})(cozydb.Model);

MailAttachment = (function(superClass) {
  extend(MailAttachment, superClass);

  function MailAttachment() {
    return MailAttachment.__super__.constructor.apply(this, arguments);
  }

  MailAttachment.schema = cozydb.NoSchema;

  return MailAttachment;

})(cozydb.Model);

module.exports = Message = (function(superClass) {
  extend(Message, superClass);

  function Message() {
    return Message.__super__.constructor.apply(this, arguments);
  }

  Message.docType = 'Message';

  Message.schema = {
    accountID: String,
    messageID: String,
    normSubject: String,
    conversationID: String,
    mailboxIDs: cozydb.NoSchema,
    hasTwin: [String],
    twinMailboxIDs: cozydb.NoSchema,
    flags: [String],
    headers: cozydb.NoSchema,
    from: [MailAdress],
    to: [MailAdress],
    cc: [MailAdress],
    bcc: [MailAdress],
    replyTo: [MailAdress],
    subject: String,
    inReplyTo: [String],
    references: [String],
    text: String,
    html: String,
    date: Date,
    priority: String,
    ignoreInCount: Boolean,
    binary: cozydb.NoSchema,
    attachments: [MailAttachment],
    alternatives: cozydb.NoSchema
  };

  Message.findMultiple = function(ids, callback) {
    return async.mapSeries(ids, function(id, cb) {
      return Message.find(id, cb);
    }, callback);
  };

  Message.pickConversationID = function(rows, callback) {
    var change, conversationID, conversationIDCounts, count, i, len, name, pickedConversationID, pickedConversationIDCount, row;
    log.debug("pickConversationID");
    conversationIDCounts = {};
    for (i = 0, len = rows.length; i < len; i++) {
      row = rows[i];
      if (conversationIDCounts[name = row.value] == null) {
        conversationIDCounts[name] = 1;
      }
      conversationIDCounts[row.value]++;
    }
    pickedConversationID = null;
    pickedConversationIDCount = 0;
    for (conversationID in conversationIDCounts) {
      count = conversationIDCounts[conversationID];
      if (count > pickedConversationIDCount) {
        pickedConversationID = conversationID;
        pickedConversationIDCount = count;
      }
    }
    if (!((pickedConversationID != null) && pickedConversationID !== 'undefined')) {
      pickedConversationID = uuid.v4();
    }
    change = {
      conversationID: pickedConversationID
    };
    return async.eachSeries(rows, function(row, cb) {
      if (row.value === pickedConversationID) {
        return cb(null);
      }
      return Message.find(row.id, function(err, message) {
        if (err) {
          log.warn("Cant get message " + row.id + ", ignoring");
        }
        if (err || message.conversationID === pickedConversationID) {
          return cb(null);
        } else {
          return message.updateAttributes(change, cb);
        }
      });
    }, function(err) {
      if (err) {
        return callback(err);
      }
      return callback(null, pickedConversationID);
    });
  };

  Message.findConversationID = function(mail, callback) {
    var isReplyOrForward, key, keys, ref, references, subject;
    log.debug("findConversationID");
    subject = mail.subject;
    isReplyOrForward = subject && mailutils.isReplyOrForward(subject);
    references = mail.references || [];
    references.concat(mail.inReplyTo || []);
    references = references.map(mailutils.normalizeMessageID).filter(function(mid) {
      return mid;
    });
    log.debug("findConversationID", references, mail.normSubject, isReplyOrForward);
    if (references.length) {
      keys = references.map(function(mid) {
        return [mail.accountID, 'mid', mid];
      });
      return Message.rawRequest('dedupRequest', {
        keys: keys
      }, function(err, rows) {
        if (err) {
          return callback(err);
        }
        log.debug('   found = ', rows != null ? rows.length : void 0);
        return Message.pickConversationID(rows, callback);
      });
    } else if (((ref = mail.normSubject) != null ? ref.length : void 0) > 3 && isReplyOrForward) {
      key = [mail.accountID, 'subject', mail.normSubject];
      return Message.rawRequest('dedupRequest', {
        key: key
      }, function(err, rows) {
        if (err) {
          return callback(err);
        }
        log.debug("found similar", rows.length);
        return Message.pickConversationID(rows, callback);
      });
    } else {
      return callback(null, uuid.v4());
    }
  };

  Message.UIDsInCozy = function(mailboxID, callback) {};

  Message.byMessageID = function(accountID, messageID, callback) {
    messageID = mailutils.normalizeMessageID(messageID);
    return Message.rawRequest('dedupRequest', {
      key: [accountID, 'mid', messageID],
      include_docs: true
    }, function(err, rows) {
      var message, ref;
      if (err) {
        return callback(err);
      }
      message = (ref = rows[0]) != null ? ref.doc : void 0;
      if (message) {
        message = new Message(message);
      }
      return callback(null, message);
    });
  };

  Message.getConversationLengths = function(conversationIDs, callback) {
    return Message.rawRequest('byConversationID', {
      keys: conversationIDs,
      group: true,
      reduce: true
    }, function(err, rows) {
      var i, len, out, row;
      if (err) {
        return callback(err);
      }
      out = {};
      for (i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        out[row.key] = row.value;
      }
      return callback(null, out);
    });
  };

  Message.byConversationID = function(conversationID, callback) {
    return Message.byConversationIDs([conversationID], callback);
  };

  Message.byConversationIDs = function(conversationIDs, callback) {
    return Message.rawRequest('byConversationID', {
      keys: conversationIDs,
      reduce: false,
      include_docs: true
    }, function(err, rows) {
      var messages;
      if (err) {
        return callback(err);
      }
      messages = rows.map(function(row) {
        var error;
        try {
          return new Message(row.doc);
        } catch (error) {
          err = error;
          log.error("Wrong message", err, row.doc);
          return null;
        }
      });
      return callback(null, messages);
    });
  };

  Message.removeFromMailbox = function(id, box, callback) {
    log.debug("removeFromMailbox", id, box.label);
    return Message.find(id, function(err, message) {
      if (err) {
        return callback(err);
      }
      if (!message) {
        return callback(new NotFound("Message " + id));
      }
      return message.removeFromMailbox(box, false, callback);
    });
  };

  Message.getResultsAndCount = function(mailboxID, params, callback) {
    var ref;
    if (params.flag == null) {
      params.flag = null;
    }
    if (params.descending) {
      ref = [params.after, params.before], params.before = ref[0], params.after = ref[1];
    }
    return async.parallel([
      function(cb) {
        return Message.getCount(mailboxID, params, cb);
      }, function(cb) {
        return Message.getResults(mailboxID, params, cb);
      }
    ], function(err, results) {
      var conversationIDs, count, messages;
      if (err) {
        return callback(err);
      }
      count = results[0], messages = results[1];
      conversationIDs = _.uniq(_.pluck(messages, 'conversationID'));
      return Message.getConversationLengths(conversationIDs, function(err, lengths) {
        if (err) {
          return callback(err);
        }
        return callback(null, {
          messages: messages,
          count: count,
          conversationLengths: lengths
        });
      });
    });
  };

  Message.getResults = function(mailboxID, params, callback) {
    var after, before, descending, endkey, flag, requestOptions, skip, sortField, startkey;
    before = params.before, after = params.after, descending = params.descending, sortField = params.sortField, flag = params.flag;
    skip = 0;
    if (sortField === 'from' || sortField === 'dest') {
      if (params.resultsAfter != null) {
        skip = params.resultsAfter;
      }
      startkey = [sortField, mailboxID, flag, before, null];
      endkey = [sortField, mailboxID, flag, after, null];
    } else {
      if (params.resultsAfter != null) {
        startkey = [sortField, mailboxID, flag, params.resultsAfter];
      } else {
        startkey = [sortField, mailboxID, flag, before];
      }
      endkey = [sortField, mailboxID, flag, after];
    }
    requestOptions = {
      descending: descending,
      startkey: startkey,
      endkey: endkey,
      reduce: false,
      skip: skip,
      include_docs: true,
      limit: MSGBYPAGE
    };
    return Message.rawRequest('byMailboxRequest', requestOptions, function(err, rows) {
      if (err) {
        return callback(err);
      }
      return callback(null, rows.map(function(row) {
        return new Message(row.doc);
      }));
    });
  };

  Message.getCount = function(mailboxID, params, callback) {
    var after, before, descending, flag, sortField;
    before = params.before, after = params.after, descending = params.descending, sortField = params.sortField, flag = params.flag;
    return Message.rawRequest('byMailboxRequest', {
      descending: descending,
      startkey: [sortField, mailboxID, flag, before],
      endkey: [sortField, mailboxID, flag, after],
      reduce: true,
      group_level: 2
    }, function(err, rows) {
      var ref;
      if (err) {
        return callback(err);
      }
      return callback(null, ((ref = rows[0]) != null ? ref.value : void 0) || 0);
    });
  };

  Message.updateOrCreate = function(message, callback) {
    log.debug("create or update");
    if (message.id) {
      return Message.find(message.id, function(err, existing) {
        log.debug("update");
        if (err) {
          return callback(err);
        } else if (!existing) {
          return callback(new NotFound("Message " + message.id));
        } else {
          message.binary = existing.binary;
          return existing.updateAttributes(message, callback);
        }
      });
    } else {
      log.debug("create");
      return Message.create(message, callback);
    }
  };

  Message.fetchOrUpdate = function(box, msg, callback) {
    var mid, uid;
    mid = msg.mid, uid = msg.uid;
    log.debug("fetchOrUpdate", box.id, mid, uid);
    return Message.byMessageID(box.accountID, mid, function(err, existing) {
      if (err) {
        return callback(err);
      }
      if (existing && !existing.isInMailbox(box)) {
        log.debug("        add");
        return existing.addToMailbox(box, uid, callback);
      } else if (existing) {
        log.debug("        twin");
        return existing.markTwin(box, uid, callback);
      } else {
        log.debug("        fetch");
        return Message.fetchOneMail(box, uid, callback);
      }
    });
  };

  Message.fetchOneMail = function(box, uid, callback) {
    return box.doLaterWithBox(function(imap, imapbox, cb) {
      return imap.fetchOneMail(uid, cb);
    }, function(err, mail) {
      var shouldNotif;
      if (err) {
        return callback(err);
      }
      shouldNotif = indexOf.call(mail.flags || [], '\\Seen') >= 0;
      return Message.createFromImapMessage(mail, box, uid, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null, {
          shouldNotif: shouldNotif,
          actuallyAdded: true
        });
      });
    });
  };

  Message.prototype.markTwin = function(box, uid, callback) {
    var hasTwin, name, name1, ref, ref1, twinMailboxIDs, twinMailboxIDsBox;
    hasTwin = this.hasTwin || [];
    twinMailboxIDs = this.twinMailboxIDs || {};
    twinMailboxIDsBox = twinMailboxIDs[box.id] || [];
    if ((ref = box.id, indexOf.call(hasTwin, ref) >= 0) && indexOf.call(twinMailboxIDsBox, uid) >= 0) {
      return callback(null, {
        shouldNotif: false,
        actuallyAdded: false
      });
    } else if (ref1 = box.id, indexOf.call(hasTwin, ref1) >= 0) {
      if (twinMailboxIDs[name = box.id] == null) {
        twinMailboxIDs[name] = [];
      }
      twinMailboxIDs[box.id].push(uid);
      return this.updateAttributes({
        twinMailboxIDs: twinMailboxIDs
      }, function(err) {
        return callback(err, {
          shouldNotif: false,
          actuallyAdded: true
        });
      });
    } else {
      hasTwin.push(box.id);
      if (twinMailboxIDs[name1 = box.id] == null) {
        twinMailboxIDs[name1] = [];
      }
      twinMailboxIDs[box.id].push(uid);
      return this.updateAttributes({
        hasTwin: hasTwin,
        twinMailboxIDs: twinMailboxIDs
      }, function(err) {
        return callback(err, {
          shouldNotif: false,
          actuallyAdded: true
        });
      });
    }
  };

  Message.prototype.addToMailbox = function(box, uid, callback) {
    var changes, key, mailboxIDs, ref, value;
    log.info("MAIL " + box.path + ":" + uid + " ADDED TO BOX");
    mailboxIDs = {};
    ref = this.mailboxIDs || {};
    for (key in ref) {
      value = ref[key];
      mailboxIDs[key] = value;
    }
    mailboxIDs[box.id] = uid;
    changes = {
      mailboxIDs: mailboxIDs
    };
    changes.ignoreInCount = box.ignoreInCount();
    return this.updateAttributes(changes, function(err) {
      return callback(err, {
        shouldNotif: false,
        actuallyAdded: true
      });
    });
  };

  Message.prototype.isInMailbox = function(box) {
    return (this.mailboxIDs[box.id] != null) && this.mailboxIDs[box.id] !== -1;
  };

  Message.prototype.removeFromMailbox = function(box, noDestroy, callback) {
    var boxes, changed, changes, isOrphan;
    if (noDestroy == null) {
      noDestroy = false;
    }
    log.debug(".removeFromMailbox", this.id, box.label);
    if (!callback) {
      callback = noDestroy;
    }
    changes = {};
    changed = false;
    if (box.id in (this.mailboxIDs || {})) {
      changes.mailboxIDs = _.omit(this.mailboxIDs, box.id);
      changed = true;
    }
    if (box.id in (this.twinMailboxIDs || {})) {
      changes.twinMailboxIDs = _.omit(this.twinMailboxIDs, box.id);
      changed = true;
    }
    if (changed) {
      boxes = Object.keys(changes.mailboxIDs || this.mailboxIDs);
      isOrphan = boxes.length === 0;
      log.debug("REMOVING " + this.id + ", NOW ORPHAN = ", isOrphan);
      if (isOrphan && !noDestroy) {
        return this.destroy(callback);
      } else {
        return this.updateAttributes(changes, callback);
      }
    } else {
      return setImmediate(callback);
    }
  };

  Message.createFromImapMessage = function(mail, box, uid, callback) {
    var attachments, messageID;
    log.info("createFromImapMessage", box.label, uid);
    log.debug('flags = ', mail.flags);
    mail.accountID = box.accountID;
    mail.ignoreInCount = box.ignoreInCount();
    mail.mailboxIDs = {};
    mail.mailboxIDs[box._id] = uid;
    messageID = mail.headers['message-id'];
    delete mail.messageId;
    if (messageID && messageID instanceof Array) {
      messageID = messageID[0];
    }
    if (messageID) {
      mail.messageID = mailutils.normalizeMessageID(messageID);
    }
    if (mail.subject) {
      mail.normSubject = mailutils.normalizeSubject(mail.subject);
    }
    if (mail.replyTo == null) {
      mail.replyTo = [];
    }
    if (mail.cc == null) {
      mail.cc = [];
    }
    if (mail.bcc == null) {
      mail.bcc = [];
    }
    if (mail.to == null) {
      mail.to = [];
    }
    if (mail.from == null) {
      mail.from = [];
    }
    if (mail.date == null) {
      mail.date = new Date().toISOString();
    }
    attachments = [];
    if (mail.attachments) {
      attachments = mail.attachments.map(function(att) {
        var buffer, out;
        buffer = att.content;
        delete att.content;
        return out = {
          name: att.generatedFileName,
          buffer: buffer
        };
      });
    }
    return Message.findConversationID(mail, function(err, conversationID) {
      if (err) {
        return callback(err);
      }
      mail.conversationID = conversationID;
      return Message.create(mail, function(err, jdbMessage) {
        if (err) {
          return callback(err);
        }
        return jdbMessage.storeAttachments(attachments, callback);
      });
    });
  };

  Message.prototype.storeAttachments = function(attachments, callback) {
    log.debug("storeAttachments");
    return async.eachSeries(attachments, (function(_this) {
      return function(att, cb) {
        if (att.buffer == null) {
          att.buffer = new Buffer(0);
        }
        return _this.attachBinary(att.buffer, {
          name: att.name
        }, cb);
      };
    })(this), callback);
  };

  Message.prototype.toClientObject = function() {
    var attachments, err, error, raw, ref;
    raw = this.toObject();
    if ((ref = raw.attachments) != null) {
      ref.forEach(function(file) {
        var encodedFileName;
        encodedFileName = encodeURIComponent(file.generatedFileName);
        return file.url = "message/" + raw.id + "/attachments/" + encodedFileName;
      });
    }
    if (raw.html != null) {
      attachments = raw.attachments || [];
      raw.html = mailutils.sanitizeHTML(raw.html, raw.id, attachments);
    }
    if ((raw.text == null) && (raw.html != null)) {
      try {
        raw.text = htmlToText.fromString(raw.html, {
          tables: true,
          wordwrap: 80
        });
      } catch (error) {
        err = error;
        log.error("Error converting HTML to text", err, raw.html);
      }
    }
    return raw;
  };

  Message.doGroupedByBox = function(messages, iterator, done) {
    var accountID, boxID, i, len, message, messagesByBoxID, ref, state, uid;
    if (messages.length === 0) {
      return done(null);
    }
    accountID = messages[0].accountID;
    messagesByBoxID = {};
    for (i = 0, len = messages.length; i < len; i++) {
      message = messages[i];
      ref = message.mailboxIDs;
      for (boxID in ref) {
        uid = ref[boxID];
        if (messagesByBoxID[boxID] == null) {
          messagesByBoxID[boxID] = [];
        }
        messagesByBoxID[boxID].push(message);
      }
    }
    state = {};
    return async.eachSeries(Object.keys(messagesByBoxID), function(boxID, next) {
      var iterator2, pool;
      state.box = ramStore.getMailbox(boxID);
      state.messagesInBox = messagesByBoxID[boxID];
      iterator2 = function(imap, imapBox, releaseImap) {
        state.imapBox = imapBox;
        state.uids = state.messagesInBox.map(function(msg) {
          return msg.mailboxIDs[state.box.id];
        });
        return iterator(imap, state, releaseImap);
      };
      pool = ramStore.getImapPool(messages[0]);
      if (!pool) {
        return done(new BadRequest("Pool isn't defined"));
      }
      return pool.doASAPWithBox(state.box, iterator2, next);
    }, done);
  };

  Message.batchAddFlag = function(messages, flag, callback) {
    messages = messages.filter(function(msg) {
      return indexOf.call(msg.flags, flag) < 0;
    });
    return Message.doGroupedByBox(messages, function(imap, state, next) {
      return imap.addFlags(state.uids, flag, next);
    }, function(err) {
      if (err) {
        return callback(err);
      }
      return async.mapSeries(messages, function(message, next) {
        var newflags;
        newflags = message.flags.concat(flag);
        return message.updateAttributes({
          flags: newflags
        }, function(err) {
          return next(err, message);
        });
      }, callback);
    });
  };

  Message.batchRemoveFlag = function(messages, flag, callback) {
    messages = messages.filter(function(msg) {
      return indexOf.call(msg.flags, flag) >= 0;
    });
    return Message.doGroupedByBox(messages, function(imap, state, next) {
      return imap.delFlags(state.uids, flag, next);
    }, function(err) {
      if (err) {
        return callback(err);
      }
      return async.mapSeries(messages, function(message, next) {
        var newflags;
        newflags = _.without(message.flags, flag);
        return message.updateAttributes({
          flags: newflags
        }, function(err) {
          return next(err, message);
        });
      }, callback);
    });
  };

  Message.prototype.cloneMailboxIDs = function() {
    var boxID, out, ref, uid;
    out = {};
    ref = this.mailboxIDs;
    for (boxID in ref) {
      uid = ref[boxID];
      out[boxID] = uid;
    }
    return out;
  };

  Message.prototype.isDraft = function(draftBoxID) {
    return (this.mailboxIDs[draftBoxID] != null) || indexOf.call(this.flags, '\\Draft') >= 0;
  };

  return Message;

})(cozydb.CozyModel);

module.exports = Message;

mailutils = require('../utils/jwz_tools');

CONSTANTS = require('../utils/constants');

MSGBYPAGE = CONSTANTS.MSGBYPAGE, LIMIT_DESTROY = CONSTANTS.LIMIT_DESTROY, CONCURRENT_DESTROY = CONSTANTS.CONCURRENT_DESTROY;

ref = require('../utils/errors'), NotFound = ref.NotFound, BadRequest = ref.BadRequest, AccountConfigError = ref.AccountConfigError;

uuid = require('uuid');

_ = require('lodash');

async = require('async');

log = require('../utils/logging')({
  prefix: 'models:message'
});

htmlToText = require('html-to-text');

require('./model-events').wrapModel(Message);

ramStore = require('./store_account_and_boxes');
