// Generated by CoffeeScript 1.7.1
var Imap, ImapPromisified, MailParser, Promise, WrongConfigError;

Imap = require('imap');

Promise = require('bluebird');

MailParser = require('mailparser').MailParser;

WrongConfigError = require('../utils/errors').WrongConfigError;

Promise.promisifyAll(Imap.prototype, {
  suffix: 'Promised'
});

module.exports = ImapPromisified = (function() {
  ImapPromisified.prototype.state = 'not connected';

  ImapPromisified.prototype.onTerminated = function() {};

  function ImapPromisified(options) {
    this._super = new Imap(options);
    this.waitConnected = new Promise((function(_this) {
      return function(resolve, reject) {
        _this._super.once('ready', function() {
          _this.state = 'connected';
          return resolve(_this);
        });
        _this._super.once('error', function(err) {
          _this.state = 'errored';
          if (_this.waitConnected.isPending()) {
            return reject(err);
          }
        });
        return _this._super.connect();
      };
    })(this)).timeout(10000, 'cant reach host')["catch"]((function(_this) {
      return function(err) {
        if (err.textCode === 'AUTHENTICATIONFAILED') {
          throw new WrongConfigError('auth');
        }
        if (err.code === 'ENOTFOUND' && err.syscall === 'getaddrinfo') {
          throw new WrongConfigError('server');
        }
        if (err instanceof Promise.TimeoutError) {
          _this._super.end();
          throw new WrongConfigError('port');
        }
        if (err.source === 'timeout-auth') {
          throw new WrongConfigError('tls');
        }
        throw err;
      };
    })(this)).tap((function(_this) {
      return function() {
        _this._super.once('error', function(err) {
          return console.log("ERROR ?", err);
        });
        _this._super.once('close', function() {
          if (!_this.waitEnding) {
            if (typeof _this.onTerminated === "function") {
              _this.onTerminated();
            }
          }
          return _this.closed = true;
        });
        return _this._super.once('end', function() {
          if (!_this.waitEnding) {
            if (typeof _this.onTerminated === "function") {
              _this.onTerminated();
            }
          }
          return _this.closed = true;
        });
      };
    })(this));
  }

  ImapPromisified.prototype.end = function(hard) {
    if (this.state === 'closed') {
      return Promise.resolve('closed');
    }
    if (this.waitEnding) {
      return this.waitEnding;
    }
    return this.waitEnding = this.waitConnected["catch"](function() {
      return Promise.resolve('closed');
    }).then((function(_this) {
      return function() {
        return new Promise(function(resolve, reject) {
          if (hard) {
            _this._super._sock.end();
            _this._super._sock.destroy();
            return resolve('closed');
          } else {
            _this._super.end();
          }
          _this._super.once('error', function() {
            return resolve(new Error('fail to logout'));
          });
          _this._super.once('end', function() {
            return resolve('closed');
          });
          return _this._super.once('close', function() {
            return resolve('closed');
          });
        });
      };
    })(this));
  };

  ImapPromisified.prototype.getBoxes = function() {
    return this._super.getBoxesPromised.apply(this._super, arguments);
  };

  ImapPromisified.prototype.openBox = function(name) {
    var _ref;
    if (((_ref = this._super._box) != null ? _ref.name : void 0) === name) {
      return Promise.resolve(this._super._box);
    }
    return this._super.openBoxPromised.apply(this._super, arguments);
  };

  ImapPromisified.prototype.search = function() {
    return this._super.searchPromised.apply(this._super, arguments);
  };

  ImapPromisified.prototype.fetchOneMail = function(id) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        var fetch, messageReceived;
        fetch = _this._super.fetch([id], {
          size: true,
          bodies: ''
        });
        messageReceived = false;
        fetch.on('message', function(msg) {
          messageReceived = true;
          msg.once('error', reject);
          msg.on('attributes', function(attrs) {});
          return msg.on('body', function(stream) {
            var parts;
            parts = [];
            stream.on('error', reject);
            stream.on('data', function(d) {
              return parts.push(d);
            });
            return stream.on('end', function() {
              var mailparser, part, _i, _len;
              mailparser = new MailParser();
              mailparser.on('error', reject);
              mailparser.on('end', resolve);
              for (_i = 0, _len = parts.length; _i < _len; _i++) {
                part = parts[_i];
                mailparser.write(part);
              }
              return mailparser.end();
            });
          });
        });
        fetch.on('error', reject);
        return fetch.on('end', function() {
          if (!messageReceived) {
            return reject(new Error('fetch ended with no message'));
          }
        });
      };
    })(this));
  };

  return ImapPromisified;

})();
